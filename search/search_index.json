{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"There Hello \u7684\u7b97\u6cd5\u77e5\u8bc6\u5e93 \u672c\u7ad9\u521d\u6b65\u5efa\u6210\ud83e\udd73\uff0c\u52aa\u529b\u5b8c\u5584\u4e2d\ud83d\ude0a\u3002 \u52aa\u529b\u5b8c\u5584\u81ea\u5df1\u7684\u7b97\u6cd5\u4f53\u7cfb\ud83d\ude0a\u3002 \u7b14\u8005\u89c9\u5f97\u628a\u7b97\u6cd5\u5355\u72ec\u505a\u6210\u7ad9\u70b9\uff0c\u7ed3\u6784\u4f1a\u66f4\u6e05\u6670\uff0c\u6545\u4e0e \u535a\u5ba2 \u5206\u79bb\u3002","title":"There Hello \u7684\u7b97\u6cd5\u77e5\u8bc6\u5e93"},{"location":"#there-hello","text":"\u672c\u7ad9\u521d\u6b65\u5efa\u6210\ud83e\udd73\uff0c\u52aa\u529b\u5b8c\u5584\u4e2d\ud83d\ude0a\u3002 \u52aa\u529b\u5b8c\u5584\u81ea\u5df1\u7684\u7b97\u6cd5\u4f53\u7cfb\ud83d\ude0a\u3002 \u7b14\u8005\u89c9\u5f97\u628a\u7b97\u6cd5\u5355\u72ec\u505a\u6210\u7ad9\u70b9\uff0c\u7ed3\u6784\u4f1a\u66f4\u6e05\u6670\uff0c\u6545\u4e0e \u535a\u5ba2 \u5206\u79bb\u3002","title":"There Hello \u7684\u7b97\u6cd5\u77e5\u8bc6\u5e93"},{"location":"ds/seg/","text":"\u7ebf\u6bb5\u6811 \u53c2\u8003\u4ee3\u7801 struct Num { ll add ; inline static Num zero (){ return { 0 };} inline Num operator + ( Num b ){ return { add + b . add };} }; struct Data { ll sum , len ; Num lazytag ; inline static Data zero (){ return { 0 , 0 , Num :: zero ()};} inline Data operator + ( Num b ){ return { sum + len * b . add , len , lazytag + b };} inline Data operator + ( Data b ){ return { sum + b . sum , len + b . len , Num :: zero ()};} }; \u53c2\u8003\u4ee3\u7801 template < class Data , class Num > struct Segment_Tree { inline void update ( int l , int r , Num x ){ update ( 1 , l , r , x );} inline Data query ( int l , int r ){ return query ( 1 , l , r );} Segment_Tree ( vector < Data >& a ){ n = a . size (); tree . assign ( n * 4 + 1 ,{}); build ( a , 1 , 0 , n - 1 ); } int n ; struct Tree { int l , r ; Data data ;}; vector < Tree > tree ; inline void pushup ( int pos ){ tree [ pos ]. data = tree [ pos << 1 ]. data + tree [ pos << 1 | 1 ]. data ; } inline void pushdown ( int pos ){ tree [ pos << 1 ]. data = tree [ pos << 1 ]. data + tree [ pos ]. data . lazytag ; tree [ pos << 1 | 1 ]. data = tree [ pos << 1 | 1 ]. data + tree [ pos ]. data . lazytag ; tree [ pos ]. data . lazytag = Num :: zero (); } void build ( vector < Data >& a , int pos , int l , int r ){ tree [ pos ]. l = l ; tree [ pos ]. r = r ; if ( l == r ){ tree [ pos ]. data = a [ l ]; return ;} int mid = ( tree [ pos ]. l + tree [ pos ]. r ) >> 1 ; build ( a , pos << 1 , l , mid ); build ( a , pos << 1 | 1 , mid + 1 , r ); pushup ( pos ); } void update ( int pos , int & l , int & r , Num & x ){ if ( l > tree [ pos ]. r || r < tree [ pos ]. l ) return ; if ( l <= tree [ pos ]. l && tree [ pos ]. r <= r ){ tree [ pos ]. data = tree [ pos ]. data + x ; return ;} pushdown ( pos ); update ( pos << 1 , l , r , x ); update ( pos << 1 | 1 , l , r , x ); pushup ( pos ); } Data query ( int pos , int & l , int & r ){ if ( l > tree [ pos ]. r || r < tree [ pos ]. l ) return Data :: zero (); if ( l <= tree [ pos ]. l && tree [ pos ]. r <= r ) return tree [ pos ]. data ; pushdown ( pos ); return query ( pos << 1 , l , r ) + query ( pos << 1 | 1 , l , r ); } };","title":"\u7ebf\u6bb5\u6811"},{"location":"ds/seg/#_1","text":"\u53c2\u8003\u4ee3\u7801 struct Num { ll add ; inline static Num zero (){ return { 0 };} inline Num operator + ( Num b ){ return { add + b . add };} }; struct Data { ll sum , len ; Num lazytag ; inline static Data zero (){ return { 0 , 0 , Num :: zero ()};} inline Data operator + ( Num b ){ return { sum + len * b . add , len , lazytag + b };} inline Data operator + ( Data b ){ return { sum + b . sum , len + b . len , Num :: zero ()};} }; \u53c2\u8003\u4ee3\u7801 template < class Data , class Num > struct Segment_Tree { inline void update ( int l , int r , Num x ){ update ( 1 , l , r , x );} inline Data query ( int l , int r ){ return query ( 1 , l , r );} Segment_Tree ( vector < Data >& a ){ n = a . size (); tree . assign ( n * 4 + 1 ,{}); build ( a , 1 , 0 , n - 1 ); } int n ; struct Tree { int l , r ; Data data ;}; vector < Tree > tree ; inline void pushup ( int pos ){ tree [ pos ]. data = tree [ pos << 1 ]. data + tree [ pos << 1 | 1 ]. data ; } inline void pushdown ( int pos ){ tree [ pos << 1 ]. data = tree [ pos << 1 ]. data + tree [ pos ]. data . lazytag ; tree [ pos << 1 | 1 ]. data = tree [ pos << 1 | 1 ]. data + tree [ pos ]. data . lazytag ; tree [ pos ]. data . lazytag = Num :: zero (); } void build ( vector < Data >& a , int pos , int l , int r ){ tree [ pos ]. l = l ; tree [ pos ]. r = r ; if ( l == r ){ tree [ pos ]. data = a [ l ]; return ;} int mid = ( tree [ pos ]. l + tree [ pos ]. r ) >> 1 ; build ( a , pos << 1 , l , mid ); build ( a , pos << 1 | 1 , mid + 1 , r ); pushup ( pos ); } void update ( int pos , int & l , int & r , Num & x ){ if ( l > tree [ pos ]. r || r < tree [ pos ]. l ) return ; if ( l <= tree [ pos ]. l && tree [ pos ]. r <= r ){ tree [ pos ]. data = tree [ pos ]. data + x ; return ;} pushdown ( pos ); update ( pos << 1 , l , r , x ); update ( pos << 1 | 1 , l , r , x ); pushup ( pos ); } Data query ( int pos , int & l , int & r ){ if ( l > tree [ pos ]. r || r < tree [ pos ]. l ) return Data :: zero (); if ( l <= tree [ pos ]. l && tree [ pos ]. r <= r ) return tree [ pos ]. data ; pushdown ( pos ); return query ( pos << 1 , l , r ) + query ( pos << 1 | 1 , l , r ); } };","title":"\u7ebf\u6bb5\u6811"},{"location":"geometry/scanning/","text":"\u626b\u63cf\u7ebf \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , tail , tot ; long long ans ; int yy [ 200005 ], val [ 200005 ]; struct pp { int len ; int tag ; } c [ 800005 ]; struct dd { int x , y_ , y__ , k ; int l , r ; inline bool operator < ( const dd y ) const { return x < y . x ; } } a [ 200005 ]; inline int read () { register int x = 0 , f = 1 ; register char ch = getchar (); while ( ch > '9' || ch < '0' ) { if ( ch == '-' ) f = - 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ) { x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return x * f ; } void modify ( int pos , int l , int r , int ll , int rr , int k ) { if ( ll <= l && r <= rr ) { c [ pos ]. tag += k ; c [ pos ]. len = c [ pos ]. tag ? val [ r + 1 ] - val [ l ] : l == r ? 0 : c [ pos << 1 ]. len + c [ pos << 1 | 1 ]. len ; return ; } int mid = l + r >> 1 , ls = pos << 1 , rs = ls | 1 ; if ( ll <= mid ) modify ( ls , l , mid , ll , rr , k ); if ( mid < rr ) modify ( rs , mid + 1 , r , ll , rr , k ); c [ pos ]. len = c [ pos ]. tag ? c [ pos ]. len : c [ ls ]. len + c [ rs ]. len ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { ++ tail ; a [ tail ]. x = read (); yy [ tail ] = read (); ++ tail ; a [ tail ]. x = read (); yy [ tail ] = read (); if ( yy [ tail - 1 ] > yy [ tail ]) swap ( yy [ tail - 1 ], yy [ tail ]); a [ tail ]. y_ = a [ tail - 1 ]. y_ = yy [ tail - 1 ]; a [ tail ]. y__ = a [ tail - 1 ]. y__ = yy [ tail ]; a [ tail ]. k = - 1 ; a [ tail - 1 ]. k = 1 ; } sort ( a + 1 , a + 1 + tail ); sort ( yy + 1 , yy + 1 + tail ); tot = unique ( yy + 1 , yy + 1 + tail ) - ( yy ); for ( int i = 1 ; i <= tail ; ++ i ) { int l = lower_bound ( yy + 1 , yy + tot , a [ i ]. y_ ) - ( yy ), r = lower_bound ( yy + 1 , yy + tot , a [ i ]. y__ ) - ( yy ); val [ l ] = a [ i ]. y_ ; val [ r ] = a [ i ]. y__ ; a [ i ]. l = l ; a [ i ]. r = r ; } -- tail ; for ( int i = 1 ; i <= tail ; ++ i ) { modify ( 1 , 1 , tail , a [ i ]. l , a [ i ]. r - 1 , a [ i ]. k ); ans += ( long long )( a [ i + 1 ]. x - a [ i ]. x ) * c [ 1 ]. len ; } printf ( \"%lld\" , ans ); }","title":"\u626b\u63cf\u7ebf"},{"location":"geometry/scanning/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , tail , tot ; long long ans ; int yy [ 200005 ], val [ 200005 ]; struct pp { int len ; int tag ; } c [ 800005 ]; struct dd { int x , y_ , y__ , k ; int l , r ; inline bool operator < ( const dd y ) const { return x < y . x ; } } a [ 200005 ]; inline int read () { register int x = 0 , f = 1 ; register char ch = getchar (); while ( ch > '9' || ch < '0' ) { if ( ch == '-' ) f = - 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ) { x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return x * f ; } void modify ( int pos , int l , int r , int ll , int rr , int k ) { if ( ll <= l && r <= rr ) { c [ pos ]. tag += k ; c [ pos ]. len = c [ pos ]. tag ? val [ r + 1 ] - val [ l ] : l == r ? 0 : c [ pos << 1 ]. len + c [ pos << 1 | 1 ]. len ; return ; } int mid = l + r >> 1 , ls = pos << 1 , rs = ls | 1 ; if ( ll <= mid ) modify ( ls , l , mid , ll , rr , k ); if ( mid < rr ) modify ( rs , mid + 1 , r , ll , rr , k ); c [ pos ]. len = c [ pos ]. tag ? c [ pos ]. len : c [ ls ]. len + c [ rs ]. len ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { ++ tail ; a [ tail ]. x = read (); yy [ tail ] = read (); ++ tail ; a [ tail ]. x = read (); yy [ tail ] = read (); if ( yy [ tail - 1 ] > yy [ tail ]) swap ( yy [ tail - 1 ], yy [ tail ]); a [ tail ]. y_ = a [ tail - 1 ]. y_ = yy [ tail - 1 ]; a [ tail ]. y__ = a [ tail - 1 ]. y__ = yy [ tail ]; a [ tail ]. k = - 1 ; a [ tail - 1 ]. k = 1 ; } sort ( a + 1 , a + 1 + tail ); sort ( yy + 1 , yy + 1 + tail ); tot = unique ( yy + 1 , yy + 1 + tail ) - ( yy ); for ( int i = 1 ; i <= tail ; ++ i ) { int l = lower_bound ( yy + 1 , yy + tot , a [ i ]. y_ ) - ( yy ), r = lower_bound ( yy + 1 , yy + tot , a [ i ]. y__ ) - ( yy ); val [ l ] = a [ i ]. y_ ; val [ r ] = a [ i ]. y__ ; a [ i ]. l = l ; a [ i ]. r = r ; } -- tail ; for ( int i = 1 ; i <= tail ; ++ i ) { modify ( 1 , 1 , tail , a [ i ]. l , a [ i ]. r - 1 , a [ i ]. k ); ans += ( long long )( a [ i + 1 ]. x - a [ i ]. x ) * c [ 1 ]. len ; } printf ( \"%lld\" , ans ); }","title":"\u626b\u63cf\u7ebf"},{"location":"graph/diff-constraints/","text":"\u5dee\u5206\u7ea6\u675f \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y,z) edge[++tail]=(dd){head[x],y,z},head[x]=tail; int n , ml , md ; int head [ 1005 ], tail ; int dis [ 1005 ], cnt [ 1005 ]; bool v [ 1005 ]; struct dd { int ne , to , w ; } edge [ 100020 ]; int spfa ( int t ){ memset ( dis , 0x3f , sizeof ( dis )); memset ( v , 0 , sizeof ( v )); memset ( cnt , 0 , sizeof ( cnt )); queue < int > q ; q . push ( t ); dis [ t ] = 0 ; while ( ! q . empty ()) { int x = q . front (); q . pop (); cnt [ x ] ++ ; if ( cnt [ x ] > n ) return - 1 ; v [ x ] = 0 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int val = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] > val ){ dis [ edge [ i ]. to ] = val ; if ( ! v [ edge [ i ]. to ]){ q . push ( edge [ i ]. to ); v [ edge [ i ]. to ] = 1 ; } } } } if ( dis [ n ] == 0x3f3f3f3f ) return - 2 ; return dis [ n ]; } int main (){ scanf ( \"%d%d%d\" , & n , & ml , & md ); for ( int i = 1 , x , y , z ; i <= ml ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); if ( x > y ) swap ( x , y ); add ( x , y , z ) } for ( int i = 1 , x , y , z ; i <= md ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); if ( x > y ) swap ( x , y ); add ( y , x , - z ) } for ( int i = 2 ; i <= n ; ++ i ) add ( i , i - 1 , 0 ) for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ) ( spfa ( 0 ) < 0 ) ? printf ( \"-1\" ) : printf ( \"%d\" , spfa ( 1 )); return 0 ; }","title":"\u5dee\u5206\u7ea6\u675f"},{"location":"graph/diff-constraints/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y,z) edge[++tail]=(dd){head[x],y,z},head[x]=tail; int n , ml , md ; int head [ 1005 ], tail ; int dis [ 1005 ], cnt [ 1005 ]; bool v [ 1005 ]; struct dd { int ne , to , w ; } edge [ 100020 ]; int spfa ( int t ){ memset ( dis , 0x3f , sizeof ( dis )); memset ( v , 0 , sizeof ( v )); memset ( cnt , 0 , sizeof ( cnt )); queue < int > q ; q . push ( t ); dis [ t ] = 0 ; while ( ! q . empty ()) { int x = q . front (); q . pop (); cnt [ x ] ++ ; if ( cnt [ x ] > n ) return - 1 ; v [ x ] = 0 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int val = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] > val ){ dis [ edge [ i ]. to ] = val ; if ( ! v [ edge [ i ]. to ]){ q . push ( edge [ i ]. to ); v [ edge [ i ]. to ] = 1 ; } } } } if ( dis [ n ] == 0x3f3f3f3f ) return - 2 ; return dis [ n ]; } int main (){ scanf ( \"%d%d%d\" , & n , & ml , & md ); for ( int i = 1 , x , y , z ; i <= ml ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); if ( x > y ) swap ( x , y ); add ( x , y , z ) } for ( int i = 1 , x , y , z ; i <= md ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); if ( x > y ) swap ( x , y ); add ( y , x , - z ) } for ( int i = 2 ; i <= n ; ++ i ) add ( i , i - 1 , 0 ) for ( int i = 1 ; i <= n ; ++ i ) add ( 0 , i , 0 ) ( spfa ( 0 ) < 0 ) ? printf ( \"-1\" ) : printf ( \"%d\" , spfa ( 1 )); return 0 ; }","title":"\u5dee\u5206\u7ea6\u675f"},{"location":"graph/hld/","text":"\u6811\u94fe\u5256\u5206 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y};head[x]=tail; int n , m , root_ , mod ; int val_ [ 101010 ], head [ 101010 ], tail , deep [ 101010 ], fa [ 101010 ]; int son [ 101010 ], size_ [ 101010 ], idx [ 101010 ], fir [ 101010 ], time_ , val_new [ 101010 ]; struct dd { int ne , to ; } edge [ 202020 ]; struct tree { int sum ; int tag ; } tree [ 404040 ]; inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return f * x ; } void dfs1 ( int t , int faa , int depth ){ deep [ t ] = depth ; fa [ t ] = faa ; size_ [ t ] = 1 ; for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ int to = edge [ i ]. to ; if ( to == faa ) continue ; dfs1 ( to , t , depth + 1 ); size_ [ t ] += size_ [ to ]; if ( size_ [ to ] > size_ [ son [ t ]]) son [ t ] = to ; } } void dfs2 ( int t , int fir_ ){ idx [ t ] =++ time_ ; val_new [ time_ ] = val_ [ t ]; fir [ t ] = fir_ ; if ( ! son [ t ]) return ; dfs2 ( son [ t ], fir_ ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! idx [ edge [ i ]. to ]){ dfs2 ( edge [ i ]. to , edge [ i ]. to ); } } } void build ( int pos , int l , int r ){ if ( l == r ){ tree [ pos ]. sum = val_new [ l ] % mod ; return ; } int mid = l + r >> 1 , lson = pos << 1 ; build ( lson , l , mid ); build ( lson | 1 , mid + 1 , r ); tree [ pos ]. sum = ( tree [ lson ]. sum + tree [ lson | 1 ]. sum ) % mod ; } inline void push_down ( int pos , int lson , int l , int r , int mid ){ tree [ lson ]. sum = ( tree [ lson ]. sum + ( mid - l + 1 ) * tree [ pos ]. tag ) % mod ; tree [ lson | 1 ]. sum = ( tree [ lson | 1 ]. sum + ( r - mid ) * tree [ pos ]. tag ) % mod ; tree [ lson ]. tag = ( tree [ lson ]. tag + tree [ pos ]. tag ) % mod ; tree [ lson | 1 ]. tag = ( tree [ lson | 1 ]. tag + tree [ pos ]. tag ) % mod ; tree [ pos ]. tag = 0 ; } void tree_update ( int pos , int l , int r , int ll , int rr , int x ){ if ( l >= ll && r <= rr ){ tree [ pos ]. tag = ( x + tree [ pos ]. tag ) % mod ; tree [ pos ]. sum = ( tree [ pos ]. sum + ( r - l + 1 ) * x ) % mod ; return ; } int mid = l + r >> 1 , lson = pos << 1 ; if ( tree [ pos ]. tag ) push_down ( pos , lson , l , r , mid ); if ( ll <= mid ) tree_update ( lson , l , mid , ll , rr , x ); if ( mid < rr ) tree_update ( lson | 1 , mid + 1 , r , ll , rr , x ); tree [ pos ]. sum = ( tree [ lson ]. sum + tree [ lson | 1 ]. sum ) % mod ; } int tree_sum ( int pos , int l , int r , int ll , int rr ){ if ( l >= ll && r <= rr ){ return tree [ pos ]. sum ; } int ans = 0 ; int mid = l + r >> 1 , lson = pos << 1 ; if ( tree [ pos ]. tag ) push_down ( pos , lson , l , r , mid ); if ( ll <= mid ) ans = tree_sum ( lson , l , mid , ll , rr ) % mod ; if ( mid < rr ) ans += tree_sum ( lson | 1 , mid + 1 , r , ll , rr ) % mod ; return ans % mod ; } inline void update ( int x , int y , int z ){ while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); tree_update ( 1 , 1 , n , idx [ fir [ x ]], idx [ x ], z ); x = fa [ fir [ x ]]; } if ( deep [ x ] > deep [ y ]) swap ( x , y ); tree_update ( 1 , 1 , n , idx [ x ], idx [ y ], z ); } inline int sum_x_y ( int x , int y ){ int ans = 0 ; while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); ans = ( ans + tree_sum ( 1 , 1 , n , idx [ fir [ x ]], idx [ x ])) % mod ; x = fa [ fir [ x ]]; } if ( deep [ x ] > deep [ y ]) swap ( x , y ); ans = ( ans + tree_sum ( 1 , 1 , n , idx [ x ], idx [ y ])) % mod ; return ans ; } int main (){ scanf ( \"%d%d%d%d\" , & n , & m , & root_ , & mod ); for ( int i = 1 ; i <= n ; ++ i ) val_ [ i ] = read (); for ( int i = 1 , x , y ; i < n ; ++ i ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs1 ( root_ , root_ , 1 ); dfs2 ( root_ , root_ ); build ( 1 , 1 , n ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ char ch = getchar (); while ( ch < '1' || ch > '4' ) ch = getchar (); if ( ch == '1' ){ x = read (); y = read (); z = read (); update ( x , y , z ); } if ( ch == '2' ){ x = read (); y = read (); printf ( \"%d \\n \" , sum_x_y ( x , y )); } if ( ch == '3' ){ x = read (); z = read (); tree_update ( 1 , 1 , n , idx [ x ], idx [ x ] + size_ [ x ] - 1 , z ); } if ( ch == '4' ){ x = read (); printf ( \"%d \\n \" , tree_sum ( 1 , 1 , n , idx [ x ], idx [ x ] + size_ [ x ] - 1 )); } } }","title":"\u6811\u94fe\u5256\u5206"},{"location":"graph/hld/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y};head[x]=tail; int n , m , root_ , mod ; int val_ [ 101010 ], head [ 101010 ], tail , deep [ 101010 ], fa [ 101010 ]; int son [ 101010 ], size_ [ 101010 ], idx [ 101010 ], fir [ 101010 ], time_ , val_new [ 101010 ]; struct dd { int ne , to ; } edge [ 202020 ]; struct tree { int sum ; int tag ; } tree [ 404040 ]; inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return f * x ; } void dfs1 ( int t , int faa , int depth ){ deep [ t ] = depth ; fa [ t ] = faa ; size_ [ t ] = 1 ; for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ int to = edge [ i ]. to ; if ( to == faa ) continue ; dfs1 ( to , t , depth + 1 ); size_ [ t ] += size_ [ to ]; if ( size_ [ to ] > size_ [ son [ t ]]) son [ t ] = to ; } } void dfs2 ( int t , int fir_ ){ idx [ t ] =++ time_ ; val_new [ time_ ] = val_ [ t ]; fir [ t ] = fir_ ; if ( ! son [ t ]) return ; dfs2 ( son [ t ], fir_ ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! idx [ edge [ i ]. to ]){ dfs2 ( edge [ i ]. to , edge [ i ]. to ); } } } void build ( int pos , int l , int r ){ if ( l == r ){ tree [ pos ]. sum = val_new [ l ] % mod ; return ; } int mid = l + r >> 1 , lson = pos << 1 ; build ( lson , l , mid ); build ( lson | 1 , mid + 1 , r ); tree [ pos ]. sum = ( tree [ lson ]. sum + tree [ lson | 1 ]. sum ) % mod ; } inline void push_down ( int pos , int lson , int l , int r , int mid ){ tree [ lson ]. sum = ( tree [ lson ]. sum + ( mid - l + 1 ) * tree [ pos ]. tag ) % mod ; tree [ lson | 1 ]. sum = ( tree [ lson | 1 ]. sum + ( r - mid ) * tree [ pos ]. tag ) % mod ; tree [ lson ]. tag = ( tree [ lson ]. tag + tree [ pos ]. tag ) % mod ; tree [ lson | 1 ]. tag = ( tree [ lson | 1 ]. tag + tree [ pos ]. tag ) % mod ; tree [ pos ]. tag = 0 ; } void tree_update ( int pos , int l , int r , int ll , int rr , int x ){ if ( l >= ll && r <= rr ){ tree [ pos ]. tag = ( x + tree [ pos ]. tag ) % mod ; tree [ pos ]. sum = ( tree [ pos ]. sum + ( r - l + 1 ) * x ) % mod ; return ; } int mid = l + r >> 1 , lson = pos << 1 ; if ( tree [ pos ]. tag ) push_down ( pos , lson , l , r , mid ); if ( ll <= mid ) tree_update ( lson , l , mid , ll , rr , x ); if ( mid < rr ) tree_update ( lson | 1 , mid + 1 , r , ll , rr , x ); tree [ pos ]. sum = ( tree [ lson ]. sum + tree [ lson | 1 ]. sum ) % mod ; } int tree_sum ( int pos , int l , int r , int ll , int rr ){ if ( l >= ll && r <= rr ){ return tree [ pos ]. sum ; } int ans = 0 ; int mid = l + r >> 1 , lson = pos << 1 ; if ( tree [ pos ]. tag ) push_down ( pos , lson , l , r , mid ); if ( ll <= mid ) ans = tree_sum ( lson , l , mid , ll , rr ) % mod ; if ( mid < rr ) ans += tree_sum ( lson | 1 , mid + 1 , r , ll , rr ) % mod ; return ans % mod ; } inline void update ( int x , int y , int z ){ while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); tree_update ( 1 , 1 , n , idx [ fir [ x ]], idx [ x ], z ); x = fa [ fir [ x ]]; } if ( deep [ x ] > deep [ y ]) swap ( x , y ); tree_update ( 1 , 1 , n , idx [ x ], idx [ y ], z ); } inline int sum_x_y ( int x , int y ){ int ans = 0 ; while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); ans = ( ans + tree_sum ( 1 , 1 , n , idx [ fir [ x ]], idx [ x ])) % mod ; x = fa [ fir [ x ]]; } if ( deep [ x ] > deep [ y ]) swap ( x , y ); ans = ( ans + tree_sum ( 1 , 1 , n , idx [ x ], idx [ y ])) % mod ; return ans ; } int main (){ scanf ( \"%d%d%d%d\" , & n , & m , & root_ , & mod ); for ( int i = 1 ; i <= n ; ++ i ) val_ [ i ] = read (); for ( int i = 1 , x , y ; i < n ; ++ i ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs1 ( root_ , root_ , 1 ); dfs2 ( root_ , root_ ); build ( 1 , 1 , n ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ char ch = getchar (); while ( ch < '1' || ch > '4' ) ch = getchar (); if ( ch == '1' ){ x = read (); y = read (); z = read (); update ( x , y , z ); } if ( ch == '2' ){ x = read (); y = read (); printf ( \"%d \\n \" , sum_x_y ( x , y )); } if ( ch == '3' ){ x = read (); z = read (); tree_update ( 1 , 1 , n , idx [ x ], idx [ x ] + size_ [ x ] - 1 , z ); } if ( ch == '4' ){ x = read (); printf ( \"%d \\n \" , tree_sum ( 1 , 1 , n , idx [ x ], idx [ x ] + size_ [ x ] - 1 )); } } }","title":"\u6811\u94fe\u5256\u5206"},{"location":"graph/layered-shortest-path/","text":"\u5206\u5c42\u6700\u77ed\u8def \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct dd { int ne , to , w ; } edge [ 4105050 ]; int n , m , k , head [ 212020 ], tail , dis [ 212020 ]; bool v [ 212020 ]; #define add(x,y,z) edge[++tail].ne=head[x];edge[tail].to=y;edge[tail].w=z;head[x]=tail; void dij (){ priority_queue < pair < int , int > > q ; q . push ( make_pair ( 0 , 1 )); while ( ! q . empty ()){ int x = q . top (). second ; q . pop (); if ( v [ x ]) continue ; v [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int diss = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] >= diss ){ dis [ edge [ i ]. to ] = diss ; q . push ( make_pair ( - diss , edge [ i ]. to )); } } } } int main (){ scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); add ( y , x , z ); for ( int j = 1 ; j <= k ; ++ j ){ add ( x + ( j - 1 ) * n , y + j * n , 0 ); add ( y + ( j - 1 ) * n , x + j * n , 0 ); add ( y + j * n , x + j * n , z ); add ( x + j * n , y + j * n , z ); } } for ( int i = 1 ; i <= n * ( k + 1 ); ++ i ) dis [ i ] = 0x7fffffff ; dis [ 1 ] = 0 ; dij (); int ans = 0x7fffffff ; for ( int i = n ; i <= n * ( k + 1 ); i += n ) ans = min ( ans , dis [ i ]); printf ( \"%d\" , ans ); }","title":"\u5206\u5c42\u6700\u77ed\u8def"},{"location":"graph/layered-shortest-path/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct dd { int ne , to , w ; } edge [ 4105050 ]; int n , m , k , head [ 212020 ], tail , dis [ 212020 ]; bool v [ 212020 ]; #define add(x,y,z) edge[++tail].ne=head[x];edge[tail].to=y;edge[tail].w=z;head[x]=tail; void dij (){ priority_queue < pair < int , int > > q ; q . push ( make_pair ( 0 , 1 )); while ( ! q . empty ()){ int x = q . top (). second ; q . pop (); if ( v [ x ]) continue ; v [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int diss = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] >= diss ){ dis [ edge [ i ]. to ] = diss ; q . push ( make_pair ( - diss , edge [ i ]. to )); } } } } int main (){ scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); add ( y , x , z ); for ( int j = 1 ; j <= k ; ++ j ){ add ( x + ( j - 1 ) * n , y + j * n , 0 ); add ( y + ( j - 1 ) * n , x + j * n , 0 ); add ( y + j * n , x + j * n , z ); add ( x + j * n , y + j * n , z ); } } for ( int i = 1 ; i <= n * ( k + 1 ); ++ i ) dis [ i ] = 0x7fffffff ; dis [ 1 ] = 0 ; dij (); int ans = 0x7fffffff ; for ( int i = n ; i <= n * ( k + 1 ); i += n ) ans = min ( ans , dis [ i ]); printf ( \"%d\" , ans ); }","title":"\u5206\u5c42\u6700\u77ed\u8def"},{"location":"graph/lca/","text":"\u6700\u8fd1\u516c\u5171\u7956\u5148 \u5e73\u5e38\u5728\u7b97\u6cd5\u7ade\u8d5b\u4e2d\u6c42LCA\u4e00\u822c\u6709\u56db\u79cd\u65b9\u6cd5 \u500d\u589e\u6cd5\u6c42\u89e3\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6\u662f \\(O(nlog\u2061n)\\) ,\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u662f \\(O(log\u2061n)\\) \u3002 \u5229\u7528\u6b27\u62c9\u5e8f\u8f6c\u5316\u4e3aRMQ\u95ee\u9898\uff0c\u7528ST\u8868\u6c42\u89e3RMQ\u95ee\u9898\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6 \\(O(n+nlogn)\\) \uff0c\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) \u3002 \u91c7\u7528Tarjan\u7b97\u6cd5\u6c42\u89e3\uff0c\u590d\u6742\u5ea6 \\(O(\u03b1(n)+Q)\\) \u3002 \u5229\u7528\u6811\u94fe\u5256\u5206\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u9884\u5904\u7406 \\(O(n)\\) \uff0c\u5355\u6b21\u67e5\u8be2 \\(O(log\u2061n)\\) \u3002 \u4e0b\u9762\u5c06\u5206\u522b\u4ecb\u7ecd\u8fd9\u56db\u79cd\u65b9\u6cd5\u3002 \u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898 \u524d\u7f6e\u77e5\u8bc6\uff1a \u53ef\u4ee5dfs\u4e00\u68f5\u6811 \u719f\u77e5st\u8868 \u6570\u7ec4\u4e0b\u6807 1 2 3 4 5 6 7 8 9 10 11 \u6b27\u62c9\u5e8f\u5217 1 2 4 2 5 2 1 3 6 3 1 \u6df1\u5ea6 1 2 3 2 3 2 1 2 3 2 1 \u5bf9\u6709\u6839\u6811\u8fdb\u884cdfs\uff0c\u65e0\u8bba\u662f\u9012\u5f52\u8fd8\u662f\u56de\u6eaf\uff0c\u6bcf\u6b21\u5230\u8fbe\u4e00\u4e2a\u7ed3\u70b9\u65f6\u90fd\u5c06\u6df1\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u8fd9\u4e2a\u4e1c\u897f\u53eb\u505a \u6b27\u62c9\u5e8f\u5217 \uff0c\u5176\u957f\u5ea6\u4e3a \\(2n-1\\) \uff0c\u4e0d\u96be\u8bc1\u660e\u3002 \u628a\u8282\u70b9 \\(k\\) \u5728\u6b27\u62c9\u5e8f\u5217\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5e8f\u53f7\u8bb0\u4e3a \\(fir(k)\\) \u3002 \u6709\u4e86\u6b27\u62c9\u5e8f\u5217\uff0c \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5316\u4e3aRMQ\u95ee\u9898 \uff0c\u5373 \\(lca(u,v)=RMQ(fir(u),fir(v))\\) \uff0c\u8fd9\u91ccRMQ\u8fd4\u56de\u7684\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u503c\u6240\u5bf9\u5e94\u7684\u8282\u70b9\u3002 \u82e5\u9700\u6c42\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\uff0c\u5229\u7528 \\(dep[u]+dep[v]-(2*dep[lca(u,v)]\\) \u53ef\u4ee5\u6c42\u5f97\u3002 \u4ed4\u7ec6\u60f3\u4e00\u4e0b\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u4e00\u5b9a\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \uff0c\u4f46\u4e0d\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \u7684\u7956\u5148\u3002\u56e0\u6b64\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u7ed3\u70b9\u5c31\u662f \\(lca(u,v)\\) \u3002 \u7528 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u6240\u4ee5 \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728 \\(O(n)\\) \u7684\u65f6\u95f4\u5185\u7528 \\(O(n)\\) \u7684\u7a7a\u95f4\u8f6c\u5316\u6210\u7b49\u89c4\u6a21\u7684 \\(RMQ\\) \u95ee\u9898\u3002 \u6b64\u5904\u5f15\u7528\u5218\u6c5d\u4f73\u300a\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178\u300b\u5e76\u505a\u9002\u5f53\u4fee\u6539\u3002 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\uff1a void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; //\u76f4\u63a5\u7528st[i][0]\u50a8\u5b58\u6b27\u62c9\u5e8f\u5217\u4e86 dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } \u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u6df1\u5ea6\u4e86\uff0c\u5148\u9884\u5904\u7406\u4e00\u4e0bst\uff1a void ready (){ lg [ 1 ] = 0 ; //\u7531\u4e8ecmath\u91cclog\u51fd\u6570\u5904\u7406\u6bd4\u8f83\u6162\uff0c\u8fd9\u91cc\u8fdb\u884c\u9884\u5904\u7406\u4e00\u4e0b for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; //\u6bd4\u8f83\u6df1\u5ea6\u8fd4\u56de\u4e0b\u6807 } \u6574\u4f53\u601d\u8def\u5c31\u662f\u8fd9\u6837 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y},head[x]=tail; #define N 505050 #define N2 1111111 struct dd { int ne , to ; } edge [ N2 ]; int head [ N ], tail , dfn_tail , fir [ N ], dep [ N ]; int n , m , s ; int st [ N2 ][ 21 ], lg [ N2 ]; inline int read (){ char c = getchar (); int res = 0 ; while ( c > '9' || c < '0' ){ c = getchar ();} while ( c <= '9' && c >= '0' ){ res *= 10 ; res += c - 48 ; c = getchar ();} return res ; } void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } void ready (){ lg [ 1 ] = 0 ; for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; } inline int query_lca ( int x , int y ){ int l = fir [ x ], r = fir [ y ]; if ( l > r ) swap ( l , r ); int k = lg [ r - l + 1 ]; return dep [ st [ l ][ k ]] < dep [ st [ r - ( 1 << k ) + 1 ][ k ]] ? st [ l ][ k ] : st [ r - ( 1 << k ) + 1 ][ k ]; } int main (){ n = read (); m = read (); s = read (); for ( int i = 1 , x , y ; i < n ; i ++ ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs ( s , s , 1 ); ready (); for ( int i = 1 , x , y ; i <= m ; i ++ ){ x = read (); y = read (); printf ( \"%d \\n \" , query_lca ( x , y )); } return 0 ; } \u6811\u94fe\u5256\u5206 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y};head[x]=tail; int n , m , root_ ; int head [ 501010 ], tail , deep [ 501010 ], fa [ 501010 ]; int son [ 501010 ], size_ [ 501010 ], fir [ 501010 ]; struct dd { int ne , to ; } edge [ 1002020 ]; inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return f * x ; } void dfs1 ( int t , int faa , int depth ){ deep [ t ] = depth ; fa [ t ] = faa ; size_ [ t ] = 1 ; for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ int to = edge [ i ]. to ; if ( to == faa ) continue ; dfs1 ( to , t , depth + 1 ); size_ [ t ] += size_ [ to ]; if ( size_ [ to ] > size_ [ son [ t ]]) son [ t ] = to ; } } void dfs2 ( int t , int fir_ ){ fir [ t ] = fir_ ; if ( ! son [ t ]) return ; dfs2 ( son [ t ], fir_ ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! fir [ edge [ i ]. to ]){ dfs2 ( edge [ i ]. to , edge [ i ]. to ); } } } inline int lca ( int x , int y ){ while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); x = fa [ fir [ x ]]; } return deep [ x ] < deep [ y ] ? x : y ; } int main (){ scanf ( \"%d%d%d\" , & n , & m , & root_ ); for ( int i = 1 , x , y ; i < n ; ++ i ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs1 ( root_ , root_ , 1 ); dfs2 ( root_ , root_ ); for ( int i = 1 , x , y ; i <= m ; ++ i ){ x = read (); y = read (); printf ( \"%d \\n \" , lca ( x , y )); } }","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"graph/lca/#_1","text":"\u5e73\u5e38\u5728\u7b97\u6cd5\u7ade\u8d5b\u4e2d\u6c42LCA\u4e00\u822c\u6709\u56db\u79cd\u65b9\u6cd5 \u500d\u589e\u6cd5\u6c42\u89e3\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6\u662f \\(O(nlog\u2061n)\\) ,\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u662f \\(O(log\u2061n)\\) \u3002 \u5229\u7528\u6b27\u62c9\u5e8f\u8f6c\u5316\u4e3aRMQ\u95ee\u9898\uff0c\u7528ST\u8868\u6c42\u89e3RMQ\u95ee\u9898\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6 \\(O(n+nlogn)\\) \uff0c\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) \u3002 \u91c7\u7528Tarjan\u7b97\u6cd5\u6c42\u89e3\uff0c\u590d\u6742\u5ea6 \\(O(\u03b1(n)+Q)\\) \u3002 \u5229\u7528\u6811\u94fe\u5256\u5206\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u9884\u5904\u7406 \\(O(n)\\) \uff0c\u5355\u6b21\u67e5\u8be2 \\(O(log\u2061n)\\) \u3002 \u4e0b\u9762\u5c06\u5206\u522b\u4ecb\u7ecd\u8fd9\u56db\u79cd\u65b9\u6cd5\u3002","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"graph/lca/#rmq","text":"\u524d\u7f6e\u77e5\u8bc6\uff1a \u53ef\u4ee5dfs\u4e00\u68f5\u6811 \u719f\u77e5st\u8868 \u6570\u7ec4\u4e0b\u6807 1 2 3 4 5 6 7 8 9 10 11 \u6b27\u62c9\u5e8f\u5217 1 2 4 2 5 2 1 3 6 3 1 \u6df1\u5ea6 1 2 3 2 3 2 1 2 3 2 1 \u5bf9\u6709\u6839\u6811\u8fdb\u884cdfs\uff0c\u65e0\u8bba\u662f\u9012\u5f52\u8fd8\u662f\u56de\u6eaf\uff0c\u6bcf\u6b21\u5230\u8fbe\u4e00\u4e2a\u7ed3\u70b9\u65f6\u90fd\u5c06\u6df1\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u8fd9\u4e2a\u4e1c\u897f\u53eb\u505a \u6b27\u62c9\u5e8f\u5217 \uff0c\u5176\u957f\u5ea6\u4e3a \\(2n-1\\) \uff0c\u4e0d\u96be\u8bc1\u660e\u3002 \u628a\u8282\u70b9 \\(k\\) \u5728\u6b27\u62c9\u5e8f\u5217\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5e8f\u53f7\u8bb0\u4e3a \\(fir(k)\\) \u3002 \u6709\u4e86\u6b27\u62c9\u5e8f\u5217\uff0c \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5316\u4e3aRMQ\u95ee\u9898 \uff0c\u5373 \\(lca(u,v)=RMQ(fir(u),fir(v))\\) \uff0c\u8fd9\u91ccRMQ\u8fd4\u56de\u7684\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u503c\u6240\u5bf9\u5e94\u7684\u8282\u70b9\u3002 \u82e5\u9700\u6c42\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\uff0c\u5229\u7528 \\(dep[u]+dep[v]-(2*dep[lca(u,v)]\\) \u53ef\u4ee5\u6c42\u5f97\u3002 \u4ed4\u7ec6\u60f3\u4e00\u4e0b\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u4e00\u5b9a\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \uff0c\u4f46\u4e0d\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \u7684\u7956\u5148\u3002\u56e0\u6b64\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u7ed3\u70b9\u5c31\u662f \\(lca(u,v)\\) \u3002 \u7528 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u6240\u4ee5 \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728 \\(O(n)\\) \u7684\u65f6\u95f4\u5185\u7528 \\(O(n)\\) \u7684\u7a7a\u95f4\u8f6c\u5316\u6210\u7b49\u89c4\u6a21\u7684 \\(RMQ\\) \u95ee\u9898\u3002 \u6b64\u5904\u5f15\u7528\u5218\u6c5d\u4f73\u300a\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178\u300b\u5e76\u505a\u9002\u5f53\u4fee\u6539\u3002 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\uff1a void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; //\u76f4\u63a5\u7528st[i][0]\u50a8\u5b58\u6b27\u62c9\u5e8f\u5217\u4e86 dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } \u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u6df1\u5ea6\u4e86\uff0c\u5148\u9884\u5904\u7406\u4e00\u4e0bst\uff1a void ready (){ lg [ 1 ] = 0 ; //\u7531\u4e8ecmath\u91cclog\u51fd\u6570\u5904\u7406\u6bd4\u8f83\u6162\uff0c\u8fd9\u91cc\u8fdb\u884c\u9884\u5904\u7406\u4e00\u4e0b for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; //\u6bd4\u8f83\u6df1\u5ea6\u8fd4\u56de\u4e0b\u6807 } \u6574\u4f53\u601d\u8def\u5c31\u662f\u8fd9\u6837 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y},head[x]=tail; #define N 505050 #define N2 1111111 struct dd { int ne , to ; } edge [ N2 ]; int head [ N ], tail , dfn_tail , fir [ N ], dep [ N ]; int n , m , s ; int st [ N2 ][ 21 ], lg [ N2 ]; inline int read (){ char c = getchar (); int res = 0 ; while ( c > '9' || c < '0' ){ c = getchar ();} while ( c <= '9' && c >= '0' ){ res *= 10 ; res += c - 48 ; c = getchar ();} return res ; } void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } void ready (){ lg [ 1 ] = 0 ; for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; } inline int query_lca ( int x , int y ){ int l = fir [ x ], r = fir [ y ]; if ( l > r ) swap ( l , r ); int k = lg [ r - l + 1 ]; return dep [ st [ l ][ k ]] < dep [ st [ r - ( 1 << k ) + 1 ][ k ]] ? st [ l ][ k ] : st [ r - ( 1 << k ) + 1 ][ k ]; } int main (){ n = read (); m = read (); s = read (); for ( int i = 1 , x , y ; i < n ; i ++ ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs ( s , s , 1 ); ready (); for ( int i = 1 , x , y ; i <= m ; i ++ ){ x = read (); y = read (); printf ( \"%d \\n \" , query_lca ( x , y )); } return 0 ; }","title":"\u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898"},{"location":"graph/lca/#_2","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y};head[x]=tail; int n , m , root_ ; int head [ 501010 ], tail , deep [ 501010 ], fa [ 501010 ]; int son [ 501010 ], size_ [ 501010 ], fir [ 501010 ]; struct dd { int ne , to ; } edge [ 1002020 ]; inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch < '0' || ch > '9' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return f * x ; } void dfs1 ( int t , int faa , int depth ){ deep [ t ] = depth ; fa [ t ] = faa ; size_ [ t ] = 1 ; for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ int to = edge [ i ]. to ; if ( to == faa ) continue ; dfs1 ( to , t , depth + 1 ); size_ [ t ] += size_ [ to ]; if ( size_ [ to ] > size_ [ son [ t ]]) son [ t ] = to ; } } void dfs2 ( int t , int fir_ ){ fir [ t ] = fir_ ; if ( ! son [ t ]) return ; dfs2 ( son [ t ], fir_ ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! fir [ edge [ i ]. to ]){ dfs2 ( edge [ i ]. to , edge [ i ]. to ); } } } inline int lca ( int x , int y ){ while ( fir [ x ] != fir [ y ]){ if ( deep [ fir [ x ]] < deep [ fir [ y ]]) swap ( x , y ); x = fa [ fir [ x ]]; } return deep [ x ] < deep [ y ] ? x : y ; } int main (){ scanf ( \"%d%d%d\" , & n , & m , & root_ ); for ( int i = 1 , x , y ; i < n ; ++ i ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs1 ( root_ , root_ , 1 ); dfs2 ( root_ , root_ ); for ( int i = 1 , x , y ; i <= m ; ++ i ){ x = read (); y = read (); printf ( \"%d \\n \" , lca ( x , y )); } }","title":"\u6811\u94fe\u5256\u5206"},{"location":"graph/scc/","text":"\u5f3a\u8fde\u901a\u5206\u91cf Tarjan\u7b97\u6cd5 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct Mystruct { int ne , to ; } edge [ 50020 ]; int head [ 10020 ], tail ; int dfn [ 10020 ], low [ 10020 ], tar_len [ 10020 ], tim_e , num ; vector < int > tar [ 10020 ]; int n , m ; bool vis [ 10020 ]; stack < int > q ; inline void add ( int x , int y ){ edge [ ++ tail ]. ne = head [ x ]; edge [ tail ]. to = y ; head [ x ] = tail ; } void tarjan ( int t ){ low [ t ] = dfn [ t ] =++ tim_e ; vis [ t ] = 1 ; q . push ( t ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! dfn [ edge [ i ]. to ]){ tarjan ( edge [ i ]. to ); low [ t ] = min ( low [ t ], low [ edge [ i ]. to ]); } else if ( vis [ edge [ i ]. to ]) low [ t ] = min ( low [ t ], dfn [ edge [ i ]. to ]); } if ( low [ t ] == dfn [ t ]){ ++ num ; int x = q . top (); while ( x != t ){ vis [ x ] = 0 ; tar [ num ]. push_back ( x ); ++ tar_len [ num ]; q . pop (); x = q . top (); } tar [ num ]. push_back ( t ); ++ tar_len [ num ]; vis [ t ] = 0 ; q . pop (); } } int main (){ scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , x , y ; i <= m ; ++ i ){ scanf ( \"%d%d\" , & x , & y ); add ( x , y ); } for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i ); int ans = 0 ; for ( int i = 1 ; i <= num ; ++ i ) if ( tar_len [ i ] > 1 ) ans ++ ; printf ( \"%d\" , ans ); }","title":"\u5f3a\u8fde\u901a\u5206\u91cf"},{"location":"graph/scc/#_1","text":"","title":"\u5f3a\u8fde\u901a\u5206\u91cf"},{"location":"graph/scc/#tarjan","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct Mystruct { int ne , to ; } edge [ 50020 ]; int head [ 10020 ], tail ; int dfn [ 10020 ], low [ 10020 ], tar_len [ 10020 ], tim_e , num ; vector < int > tar [ 10020 ]; int n , m ; bool vis [ 10020 ]; stack < int > q ; inline void add ( int x , int y ){ edge [ ++ tail ]. ne = head [ x ]; edge [ tail ]. to = y ; head [ x ] = tail ; } void tarjan ( int t ){ low [ t ] = dfn [ t ] =++ tim_e ; vis [ t ] = 1 ; q . push ( t ); for ( int i = head [ t ]; i ; i = edge [ i ]. ne ){ if ( ! dfn [ edge [ i ]. to ]){ tarjan ( edge [ i ]. to ); low [ t ] = min ( low [ t ], low [ edge [ i ]. to ]); } else if ( vis [ edge [ i ]. to ]) low [ t ] = min ( low [ t ], dfn [ edge [ i ]. to ]); } if ( low [ t ] == dfn [ t ]){ ++ num ; int x = q . top (); while ( x != t ){ vis [ x ] = 0 ; tar [ num ]. push_back ( x ); ++ tar_len [ num ]; q . pop (); x = q . top (); } tar [ num ]. push_back ( t ); ++ tar_len [ num ]; vis [ t ] = 0 ; q . pop (); } } int main (){ scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , x , y ; i <= m ; ++ i ){ scanf ( \"%d%d\" , & x , & y ); add ( x , y ); } for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i ); int ans = 0 ; for ( int i = 1 ; i <= num ; ++ i ) if ( tar_len [ i ] > 1 ) ans ++ ; printf ( \"%d\" , ans ); }","title":"Tarjan\u7b97\u6cd5"},{"location":"graph/shortest-path/","text":"\u6700\u77ed\u8def Dijkstra \u7b97\u6cd5 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct dd { int ne , to , w ; } edge [ 505050 ]; int n , m , s , head [ 101001 ], tail , dis [ 101001 ]; bool v [ 101001 ]; #define add(x,y,z) edge[++tail]=(dd){head[x],y,z};head[x]=tail; void dij (){ priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > q ; q . push ( make_pair ( 0 , s )); while ( ! q . empty ()){ int x = q . top (). second ; q . pop (); if ( v [ x ]) continue ; v [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int diss = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] >= diss ){ dis [ edge [ i ]. to ] = diss ; q . push ( make_pair ( diss , edge [ i ]. to )); } } } } int main (){ scanf ( \"%d%d%d\" , & n , & m , & s ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } for ( int i = 1 ; i <= n ; ++ i ) dis [ i ] = 0x7fffffff ; dis [ s ] = 0 ; dij (); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \" , dis [ i ]); }","title":"\u6700\u77ed\u8def"},{"location":"graph/shortest-path/#_1","text":"","title":"\u6700\u77ed\u8def"},{"location":"graph/shortest-path/#dijkstra","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; struct dd { int ne , to , w ; } edge [ 505050 ]; int n , m , s , head [ 101001 ], tail , dis [ 101001 ]; bool v [ 101001 ]; #define add(x,y,z) edge[++tail]=(dd){head[x],y,z};head[x]=tail; void dij (){ priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > q ; q . push ( make_pair ( 0 , s )); while ( ! q . empty ()){ int x = q . top (). second ; q . pop (); if ( v [ x ]) continue ; v [ x ] = 1 ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ int diss = dis [ x ] + edge [ i ]. w ; if ( dis [ edge [ i ]. to ] >= diss ){ dis [ edge [ i ]. to ] = diss ; q . push ( make_pair ( diss , edge [ i ]. to )); } } } } int main (){ scanf ( \"%d%d%d\" , & n , & m , & s ); for ( int i = 1 , x , y , z ; i <= m ; ++ i ){ scanf ( \"%d%d%d\" , & x , & y , & z ); add ( x , y , z ); } for ( int i = 1 ; i <= n ; ++ i ) dis [ i ] = 0x7fffffff ; dis [ s ] = 0 ; dij (); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \" , dis [ i ]); }","title":"Dijkstra \u7b97\u6cd5"},{"location":"misc/count-inversions/","text":"\u9006\u5e8f\u5bf9 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , tree [ 555555 ]; struct dd { int v , pos ; } a [ 555555 ]; long long ans = 0 ; #define lowbit(x) ((x)&(-x)) inline bool cmp ( dd x , dd y ){ return x . v == y . v ? x . pos > y . pos : x . v > y . v ; } void update ( int t , int x ){ while ( t <= n ){ tree [ t ] += x ; t += lowbit ( t ); } } int sum ( int t ){ int tot = 0 ; while ( t ){ tot += tree [ t ]; t -= lowbit ( t ); } return tot ; } inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch > '9' || ch < '0' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return x * f ; } int main (){ n = read (); for ( int i = 1 ; i <= n ; ++ i ){ a [ i ]. v = read (); a [ i ]. pos = i ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; ++ i ){ ans += sum ( a [ i ]. pos ); update ( a [ i ]. pos , 1 ); } printf ( \"%lld\" , ans ); }","title":"\u9006\u5e8f\u5bf9"},{"location":"misc/count-inversions/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , tree [ 555555 ]; struct dd { int v , pos ; } a [ 555555 ]; long long ans = 0 ; #define lowbit(x) ((x)&(-x)) inline bool cmp ( dd x , dd y ){ return x . v == y . v ? x . pos > y . pos : x . v > y . v ; } void update ( int t , int x ){ while ( t <= n ){ tree [ t ] += x ; t += lowbit ( t ); } } int sum ( int t ){ int tot = 0 ; while ( t ){ tot += tree [ t ]; t -= lowbit ( t ); } return tot ; } inline int read (){ int x = 0 , f = 1 ; char ch = getchar (); while ( ch > '9' || ch < '0' ){ if ( ch == '-' ) f =- 1 ; ch = getchar (); } while ( ch >= '0' && ch <= '9' ){ x = x * 10 + ( ch ^ 48 ); ch = getchar (); } return x * f ; } int main (){ n = read (); for ( int i = 1 ; i <= n ; ++ i ){ a [ i ]. v = read (); a [ i ]. pos = i ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; ++ i ){ ans += sum ( a [ i ]. pos ); update ( a [ i ]. pos , 1 ); } printf ( \"%lld\" , ans ); }","title":"\u9006\u5e8f\u5bf9"},{"location":"misc/hoverline/","text":"\u60ac\u7ebf\u6cd5 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , m , ans ; int a [ 1005 ][ 1005 ]; int l [ 1005 ][ 1005 ], r [ 1005 ][ 1005 ], h [ 1005 ][ 1005 ]; inline char read (){ char ch = getchar (); while ( ch != 'R' && ch != 'F' ) ch = getchar (); return ch ; } int main (){ cin >> n >> m ; char ch ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ ch = read (); if ( ch == 'F' ) a [ i ][ j ] = 1 ; } } for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 2 ; j <= m ; ++ j ) if ( a [ i ][ j ] == a [ i ][ j - 1 ] && a [ i ][ j ]) l [ i ][ j ] = l [ i ][ j - 1 ] + 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = m - 1 ; j ; -- j ) if ( a [ i ][ j ] == a [ i ][ j + 1 ] && a [ i ][ j ]) r [ i ][ j ] = r [ i ][ j + 1 ] + 1 ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( a [ i ][ j ] && a [ i ][ j ] == a [ i - 1 ][ j ]){ l [ i ][ j ] = min ( l [ i ][ j ], l [ i - 1 ][ j ]); r [ i ][ j ] = min ( r [ i ][ j ], r [ i - 1 ][ j ]); h [ i ][ j ] = h [ i - 1 ][ j ] + 1 ; } ans = max ( ans ,( l [ i ][ j ] + r [ i ][ j ] + 1 ) * ( h [ i ][ j ] + 1 )); } } cout << ans * 3 ; }","title":"\u60ac\u7ebf\u6cd5"},{"location":"misc/hoverline/#_1","text":"\u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; int n , m , ans ; int a [ 1005 ][ 1005 ]; int l [ 1005 ][ 1005 ], r [ 1005 ][ 1005 ], h [ 1005 ][ 1005 ]; inline char read (){ char ch = getchar (); while ( ch != 'R' && ch != 'F' ) ch = getchar (); return ch ; } int main (){ cin >> n >> m ; char ch ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ ch = read (); if ( ch == 'F' ) a [ i ][ j ] = 1 ; } } for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 2 ; j <= m ; ++ j ) if ( a [ i ][ j ] == a [ i ][ j - 1 ] && a [ i ][ j ]) l [ i ][ j ] = l [ i ][ j - 1 ] + 1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = m - 1 ; j ; -- j ) if ( a [ i ][ j ] == a [ i ][ j + 1 ] && a [ i ][ j ]) r [ i ][ j ] = r [ i ][ j + 1 ] + 1 ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( a [ i ][ j ] && a [ i ][ j ] == a [ i - 1 ][ j ]){ l [ i ][ j ] = min ( l [ i ][ j ], l [ i - 1 ][ j ]); r [ i ][ j ] = min ( r [ i ][ j ], r [ i - 1 ][ j ]); h [ i ][ j ] = h [ i - 1 ][ j ] + 1 ; } ans = max ( ans ,( l [ i ][ j ] + r [ i ][ j ] + 1 ) * ( h [ i ][ j ] + 1 )); } } cout << ans * 3 ; }","title":"\u60ac\u7ebf\u6cd5"}]}