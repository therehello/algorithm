{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ]","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ]","title":"Welcome to MkDocs"},{"location":"lca/","text":"\u6700\u8fd1\u516c\u5171\u7956\u5148 \u5e73\u5e38\u5728\u4fe1\u606f\u5b66\u7ade\u8d5b\u4e2d\u6c42LCA\u4e00\u822c\u6709\u56db\u79cd\u529e\u6cd5 \u500d\u589e\u6cd5\u6c42\u89e3\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6\u662f \\(O(nlog\u2061n)\\) ,\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u662f \\(O(log\u2061n)\\) \u3002 \u5229\u7528\u6b27\u62c9\u5e8f\u8f6c\u5316\u4e3aRMQ\u95ee\u9898\uff0c\u7528ST\u8868\u6c42\u89e3RMQ\u95ee\u9898\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6 \\(O(n+nlogn)\\) \uff0c\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) \u3002 \u91c7\u7528Tarjan\u7b97\u6cd5\u6c42\u89e3\uff0c\u590d\u6742\u5ea6 \\(O(\u03b1(n)+Q)\\) \u3002 \u5229\u7528\u6811\u94fe\u5256\u5206\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u9884\u5904\u7406 \\(O(n)\\) \uff0c\u5355\u6b21\u67e5\u8be2 \\(O(log\u2061n)\\) \u3002 \u4e0b\u9762\u5c06\u8be6\u7ec6\u5730\u4ecb\u7ecd\u201c\u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898\u201d\u3002 \u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898 \u6e29\u99a8\u63d0\u793a\uff0c\u82e5\u60f3\u66f4\u597d\u5730\u9605\u8bfb\u672c\u6587\u7ae0\uff0c\u4f60\u9700\u8981\u638c\u63e1\u4e00\u4e0b\u77e5\u8bc6\uff1a \u53ef\u4ee5dfs\u4e00\u68f5\u6811 \u719f\u77e5st\u8868 \u6570\u7ec4\u4e0b\u6807 1 2 3 4 5 6 7 8 9 10 11 \u6b27\u62c9\u5e8f\u5217 1 2 4 2 5 2 1 3 6 3 1 \u6df1\u5ea6 1 2 3 2 3 2 1 2 3 2 1 \u5bf9\u6709\u6839\u6811\u8fdb\u884cdfs\uff0c\u65e0\u8bba\u662f\u9012\u5f52\u8fd8\u662f\u56de\u6eaf\uff0c\u6bcf\u6b21\u5230\u8fbe\u4e00\u4e2a\u7ed3\u70b9\u65f6\u90fd\u5c06\u6df1\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u8fd9\u4e2a\u4e1c\u897f\u53eb\u505a \u6b27\u62c9\u5e8f\u5217 \uff0c\u5176\u957f\u5ea6\u4e3a \\(2n-1\\) \uff0c\u4e0d\u96be\u8bc1\u660e\u3002 \u628a\u8282\u70b9 \\(k\\) \u5728\u6b27\u62c9\u5e8f\u5217\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5e8f\u53f7\u8bb0\u4e3a \\(fir(k)\\) \u3002 \u6709\u4e86\u6b27\u62c9\u5e8f\u5217\uff0c \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5316\u4e3aRMQ\u95ee\u9898 \uff0c\u5373 \\(lca(u,v)=RMQ(fir(u),fir(v))\\) \uff0c\u8fd9\u91ccRMQ\u8fd4\u56de\u7684\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u503c\u6240\u5bf9\u5e94\u7684\u8282\u70b9\u3002 \u82e5\u9700\u6c42\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\uff0c\u5229\u7528 \\(dep[u]+dep[v]-(2*dep[lca(u,v)]\\) \u53ef\u4ee5\u6c42\u5f97\u3002 \u4ed4\u7ec6\u60f3\u4e00\u4e0b\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u4e00\u5b9a\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \uff0c\u4f46\u4e0d\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \u7684\u7956\u5148\u3002\u56e0\u6b64\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u7ed3\u70b9\u5c31\u662f \\(lca(u,v)\\) \u3002 \u7528 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u6240\u4ee5 \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728 \\(O(n)\\) \u7684\u65f6\u95f4\u5185\u7528 \\(O(n)\\) \u7684\u7a7a\u95f4\u8f6c\u5316\u6210\u7b49\u89c4\u6a21\u7684 \\(RMQ\\) \u95ee\u9898\u3002 \u6b64\u5904\u5f15\u7528\u5218\u6c5d\u4f73\u300a\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178\u300b\u5e76\u505a\u9002\u5f53\u4fee\u6539\u3002 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\uff1a void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; //\u76f4\u63a5\u7528st[i][0]\u50a8\u5b58\u6b27\u62c9\u5e8f\u5217\u4e86 dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } \u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u6df1\u5ea6\u4e86\uff0c\u5148\u9884\u5904\u7406\u4e00\u4e0bst\uff1a void ready (){ lg [ 1 ] = 0 ; //\u7531\u4e8ecmath\u91cclog\u51fd\u6570\u5904\u7406\u6bd4\u8f83\u6162\uff0c\u8fd9\u91cc\u8fdb\u884c\u9884\u5904\u7406\u4e00\u4e0b for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; //\u6bd4\u8f83\u6df1\u5ea6\u8fd4\u56de\u4e0b\u6807 } \u6574\u4f53\u601d\u8def\u5c31\u662f\u8fd9\u6837 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y},head[x]=tail; #define N 505050 #define N2 1111111 struct dd { int ne , to ; } edge [ N2 ]; int head [ N ], tail , dfn_tail , fir [ N ], dep [ N ]; int n , m , s ; int st [ N2 ][ 21 ], lg [ N2 ]; inline int read (){ char c = getchar (); int res = 0 ; while ( c > '9' || c < '0' ){ c = getchar ();} while ( c <= '9' && c >= '0' ){ res *= 10 ; res += c - 48 ; c = getchar ();} return res ; } void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } void ready (){ lg [ 1 ] = 0 ; for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; } inline int query_lca ( int x , int y ){ int l = fir [ x ], r = fir [ y ]; if ( l > r ) swap ( l , r ); int k = lg [ r - l + 1 ]; return dep [ st [ l ][ k ]] < dep [ st [ r - ( 1 << k ) + 1 ][ k ]] ? st [ l ][ k ] : st [ r - ( 1 << k ) + 1 ][ k ]; } int main (){ n = read (); m = read (); s = read (); for ( int i = 1 , x , y ; i < n ; i ++ ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs ( s , s , 1 ); ready (); for ( int i = 1 , x , y ; i <= m ; i ++ ){ x = read (); y = read (); printf ( \"%d \\n \" , query_lca ( x , y )); } return 0 ; }","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"lca/#_1","text":"","title":"\u6700\u8fd1\u516c\u5171\u7956\u5148"},{"location":"lca/#lca","text":"\u500d\u589e\u6cd5\u6c42\u89e3\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6\u662f \\(O(nlog\u2061n)\\) ,\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u662f \\(O(log\u2061n)\\) \u3002 \u5229\u7528\u6b27\u62c9\u5e8f\u8f6c\u5316\u4e3aRMQ\u95ee\u9898\uff0c\u7528ST\u8868\u6c42\u89e3RMQ\u95ee\u9898\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6 \\(O(n+nlogn)\\) \uff0c\u6bcf\u6b21\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u4e3a \\(O(1)\\) \u3002 \u91c7\u7528Tarjan\u7b97\u6cd5\u6c42\u89e3\uff0c\u590d\u6742\u5ea6 \\(O(\u03b1(n)+Q)\\) \u3002 \u5229\u7528\u6811\u94fe\u5256\u5206\u6c42\u89e3\uff0c\u590d\u6742\u5ea6\u9884\u5904\u7406 \\(O(n)\\) \uff0c\u5355\u6b21\u67e5\u8be2 \\(O(log\u2061n)\\) \u3002 \u4e0b\u9762\u5c06\u8be6\u7ec6\u5730\u4ecb\u7ecd\u201c\u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898\u201d\u3002","title":"\u5e73\u5e38\u5728\u4fe1\u606f\u5b66\u7ade\u8d5b\u4e2d\u6c42LCA\u4e00\u822c\u6709\u56db\u79cd\u529e\u6cd5"},{"location":"lca/#rmq","text":"\u6e29\u99a8\u63d0\u793a\uff0c\u82e5\u60f3\u66f4\u597d\u5730\u9605\u8bfb\u672c\u6587\u7ae0\uff0c\u4f60\u9700\u8981\u638c\u63e1\u4e00\u4e0b\u77e5\u8bc6\uff1a \u53ef\u4ee5dfs\u4e00\u68f5\u6811 \u719f\u77e5st\u8868 \u6570\u7ec4\u4e0b\u6807 1 2 3 4 5 6 7 8 9 10 11 \u6b27\u62c9\u5e8f\u5217 1 2 4 2 5 2 1 3 6 3 1 \u6df1\u5ea6 1 2 3 2 3 2 1 2 3 2 1 \u5bf9\u6709\u6839\u6811\u8fdb\u884cdfs\uff0c\u65e0\u8bba\u662f\u9012\u5f52\u8fd8\u662f\u56de\u6eaf\uff0c\u6bcf\u6b21\u5230\u8fbe\u4e00\u4e2a\u7ed3\u70b9\u65f6\u90fd\u5c06\u6df1\u5ea6\u8bb0\u5f55\u4e0b\u6765\uff0c\u8fd9\u4e2a\u4e1c\u897f\u53eb\u505a \u6b27\u62c9\u5e8f\u5217 \uff0c\u5176\u957f\u5ea6\u4e3a \\(2n-1\\) \uff0c\u4e0d\u96be\u8bc1\u660e\u3002 \u628a\u8282\u70b9 \\(k\\) \u5728\u6b27\u62c9\u5e8f\u5217\u4e2d\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684\u5e8f\u53f7\u8bb0\u4e3a \\(fir(k)\\) \u3002 \u6709\u4e86\u6b27\u62c9\u5e8f\u5217\uff0c \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728\u7ebf\u6027\u65f6\u95f4\u5185\u5316\u4e3aRMQ\u95ee\u9898 \uff0c\u5373 \\(lca(u,v)=RMQ(fir(u),fir(v))\\) \uff0c\u8fd9\u91ccRMQ\u8fd4\u56de\u7684\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u503c\u6240\u5bf9\u5e94\u7684\u8282\u70b9\u3002 \u82e5\u9700\u6c42\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\uff0c\u5229\u7528 \\(dep[u]+dep[v]-(2*dep[lca(u,v)]\\) \u53ef\u4ee5\u6c42\u5f97\u3002 \u4ed4\u7ec6\u60f3\u4e00\u4e0b\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u4e00\u5b9a\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \uff0c\u4f46\u4e0d\u4f1a\u7ecf\u8fc7 \\(lca(u,v)\\) \u7684\u7956\u5148\u3002\u56e0\u6b64\uff0c\u4ece \\(u\\) \u8d70\u5230 \\(v\\) \u7684\u8fc7\u7a0b\u4e2d\u7ecf\u8fc7\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u7ed3\u70b9\u5c31\u662f \\(lca(u,v)\\) \u3002 \u7528 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\u7684\u65f6\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 \\(O(n)\\) \uff0c\u6240\u4ee5 \\(lca\\) \u95ee\u9898\u53ef\u4ee5\u5728 \\(O(n)\\) \u7684\u65f6\u95f4\u5185\u7528 \\(O(n)\\) \u7684\u7a7a\u95f4\u8f6c\u5316\u6210\u7b49\u89c4\u6a21\u7684 \\(RMQ\\) \u95ee\u9898\u3002 \u6b64\u5904\u5f15\u7528\u5218\u6c5d\u4f73\u300a\u7b97\u6cd5\u7ade\u8d5b\u5165\u95e8\u7ecf\u5178\u300b\u5e76\u505a\u9002\u5f53\u4fee\u6539\u3002 \\(dfs\\) \u8ba1\u7b97\u6b27\u62c9\u5e8f\u5217\uff1a void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; //\u76f4\u63a5\u7528st[i][0]\u50a8\u5b58\u6b27\u62c9\u5e8f\u5217\u4e86 dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } \u73b0\u5728\u5df2\u7ecf\u77e5\u9053\u6df1\u5ea6\u4e86\uff0c\u5148\u9884\u5904\u7406\u4e00\u4e0bst\uff1a void ready (){ lg [ 1 ] = 0 ; //\u7531\u4e8ecmath\u91cclog\u51fd\u6570\u5904\u7406\u6bd4\u8f83\u6162\uff0c\u8fd9\u91cc\u8fdb\u884c\u9884\u5904\u7406\u4e00\u4e0b for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; //\u6bd4\u8f83\u6df1\u5ea6\u8fd4\u56de\u4e0b\u6807 } \u6574\u4f53\u601d\u8def\u5c31\u662f\u8fd9\u6837 \u53c2\u8003\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; #define add(x,y) edge[++tail]=(dd){head[x],y},head[x]=tail; #define N 505050 #define N2 1111111 struct dd { int ne , to ; } edge [ N2 ]; int head [ N ], tail , dfn_tail , fir [ N ], dep [ N ]; int n , m , s ; int st [ N2 ][ 21 ], lg [ N2 ]; inline int read (){ char c = getchar (); int res = 0 ; while ( c > '9' || c < '0' ){ c = getchar ();} while ( c <= '9' && c >= '0' ){ res *= 10 ; res += c - 48 ; c = getchar ();} return res ; } void dfs ( int x , int fa , int depth ){ st [ ++ dfn_tail ][ 0 ] = x ; dep [ x ] = depth ; fir [ x ] = dfn_tail ; for ( int i = head [ x ]; i ; i = edge [ i ]. ne ){ if ( edge [ i ]. to != fa ){ dfs ( edge [ i ]. to , x , depth + 1 ); st [ ++ dfn_tail ][ 0 ] = x ; } } } void ready (){ lg [ 1 ] = 0 ; for ( int i = 2 ; i <= dfn_tail ; i ++ ) lg [ i ] = lg [ i >> 1 ] + 1 ; for ( int j = 1 ; j <= lg [ dfn_tail ]; j ++ ) for ( int i = 1 ; i <= dfn_tail - ( 1 << j ) + 1 ; i ++ ) st [ i ][ j ] = dep [ st [ i ][ j - 1 ]] < dep [ st [ i + ( 1 << ( j - 1 ))][ j - 1 ]] ? st [ i ][ j - 1 ] : st [ i + ( 1 << ( j - 1 ))][ j - 1 ]; } inline int query_lca ( int x , int y ){ int l = fir [ x ], r = fir [ y ]; if ( l > r ) swap ( l , r ); int k = lg [ r - l + 1 ]; return dep [ st [ l ][ k ]] < dep [ st [ r - ( 1 << k ) + 1 ][ k ]] ? st [ l ][ k ] : st [ r - ( 1 << k ) + 1 ][ k ]; } int main (){ n = read (); m = read (); s = read (); for ( int i = 1 , x , y ; i < n ; i ++ ){ x = read (); y = read (); add ( x , y ); add ( y , x ); } dfs ( s , s , 1 ); ready (); for ( int i = 1 , x , y ; i <= m ; i ++ ){ x = read (); y = read (); printf ( \"%d \\n \" , query_lca ( x , y )); } return 0 ; }","title":"\u7528\u6b27\u62c9\u5e8f\u8f6c\u6362\u4e3aRMQ\u95ee\u9898"}]}